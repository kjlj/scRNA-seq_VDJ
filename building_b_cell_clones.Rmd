---
title: "Building Ig clones"
date: "2023-08-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

Clustering of the Ig sequences is intended to identify groups of cells that carry sequences that are derived from the same original progentitor B cell. These cells will carry heavy and light chains with similar nucleotide sequences that have diverged due to the accumulation of point mutations. Clustering must be undertaken for each individual as a clonal lineage can only exist within a single individual. Similar Igs from different individuals are 'convergent' antibodies likely responding to the same antigen rather than 'divergent' members of the same clone. The same type of clustering can be used to explore convergence (aka public clones) in antibody responses but this is in addition to the clonal lineages.

In the example datasets the pbmc and tumour samples are from different individuals so clones will be built separately. If your 10x dataset includes multiplexed samples you must split the B cell V(D)J data before building clones. 

Generally, hierarchical clustering is used on the CDR3 nucleotides sequences to group sequences at a specific threshold. First, the sequences are binned by V, J and CDR3 length as any clone will share these three features. The process within each bin then involves seeding the first cluster with the first sequence, then the next sequence is compared to whether or not it is within an identity threshold, if it is then it is added to the cluster, if not, it becomes the first member of a new cluster. This process is repeated until all sequences are assigned to clusters. Generally a centroid approach is taken, this means that adding a new sequence to a cluster doesn't increase average distance between cluster members beyond a threshold. This aims to prevent 'daisy-chaining', where a sequence may be within the threshold of a single member of a cluster but is increasing distance from other members.

An excellent resource for post-processing of 10x data including building clonal relationships can be found at <https://immcantation.readthedocs.io/en/stable/tutorials/10x_tutorial.html>. This approach can be undertaken in R, but can also export data and use alternative tools such as cd-hit <https://github.com/weizhongli/cdhit>.

This workflow assumes that input files are Ig summaries for each cell barcode for cellranger + IgBLAST that were generated from workflow described at <joining_cellranger_igblast.html>.

## Working locally versus working on Posit Cloud

If working locally it may be of benefit to set the working directory at the start of your R session so that you can use relative file paths, this isn't required when using RStudio on Posit Cloud.

```{r set_working_dir}
setwd("~/Documents/GitHub/scRNA-seq_VDJ/")
```

## R packages

The tidyverse collection of R packages <https://www.tidyverse.org/> will be used to manipulate the datasets. To install this package (if it is not already available) and then load:
```{r install_packages}
#check if the package is already installed, if not, install it
if (sum(grepl("tidyverse", rownames(installed.packages()))) > 0) {
  print("tidyverse is already installed")
} else {
  install.packages("tidyverse")
}

#loading R packages
library(tidyverse)
```

To undertake the clone clustering will use two packages from the Immcantation framework <https://immcantation.readthedocs.io/en/stable/>; SCOPer <https://scoper.readthedocs.io/en/stable/> and SHazaM <https://shazam.readthedocs.io/en/stable/>.
```{r install_packages2}
#check if the package is already installed, if not, install it
if (sum(grepl("scoper", rownames(installed.packages()))) > 0) {
  print("SCOPer is already installed")
} else {
  install.packages("scoper")
}

if (sum(grepl("shazam", rownames(installed.packages()))) > 0) {
  print("SHazaM is already installed")
} else {
  install.packages("shazam")
}

#loading R packages
library(scoper)
library(shazam)
```

## Themes for ggplot2

Adding some custom ggplot2 themes for plotting:
```{r ggplot_themes}
##themes for plots
theme_custom <- function (base_size = 12) { 
  theme_bw(base_size=base_size) %+replace% 
    theme(panel.grid = element_blank(),
          panel.border = element_blank(),
          axis.line = element_line(colour="black"),
          axis.text.x = element_text(colour="black", size=base_size),
          axis.text.y = element_text(colour="black", size = base_size, hjust = 1),
          axis.title = element_text(colour="black", face="bold", size = base_size),
          strip.background = element_blank(),
          strip.text = element_text(colour="black", face="bold", size=base_size),
          legend.text = element_text(colour="black", size=base_size)
    )
}

theme_x_rotated <- function (base_size = 12) { 
  theme_custom(base_size=base_size) %+replace% 
    theme(axis.text.x = element_text(colour="black", angle = 90, hjust = 1, vjust = 0.5, size=base_size))
}
```

## Datasets

Using the Ig dataset that was output from <joining_cell_ranger_igblast.html>. Loading this from githib repo, but can be loaded locally by changing to a file path rather than a URL.
```{r loading_datasets}
#loading the B cell post-processed data
bcr.data <- read_tsv("https://raw.githubusercontent.com/kjlj/scRNA-seq_VDJ/main/pbmc-tumour_Ig_cellranger_igblast_per-barcode.tsv")

table(bcr.data$dataset)
```

As clones are defined within a single individual, need to separate the PBMC and Tumour:
```{r splitting_datasets}
#split into tumour and pbmc
pbmc.data <- bcr.data %>% filter(dataset == "pbmc")
tumour.data <- bcr.data %>% filter(dataset == "tumour")

#check the number of cells in each after the split
pbmc.data %>% nrow()
tumour.data %>% nrow()
```

## Set the clustering threshold

Before performing the heirachical clustering need to find the clustering threshold. This is done by comparing the hamming distance between sequences which should result in a bimodal distribution that define 'clones' and 'unrelated' sequences. For this, we can use the IGH data. The SHazaM package expects IgBLAST column names so we need to extract those columns and rename them to remove the _iglbast_igh suffix that we appended previously:
```{r igh_shazam_format}
## the shazam package uses the IgBLAST columns, so can just select those and rename appropriately
pbmc.igh.data <- pbmc.data %>% 
  select(barcode, sequence_id = contig_id_igh, ends_with("_igblast_igh")) %>%
  rename_with(~ str_replace(.x, "_igblast_igh", ""), everything()) %>%
  filter(!(is.na(cdr3))) #need to remove any unpaired entries as they will cause errors

tumour.igh.data <- tumour.data %>%
  select(barcode, sequence_id = contig_id_igh, ends_with("_igblast_igh")) %>%
  rename_with(~ str_replace(.x, "_igblast_igh", ""), everything()) %>%
  filter(!(is.na(cdr3))) #need to remove any unpaired entries as they will cause errors
```

Check that the column names are as expected:
```{r view_igh_shazam_format}
pbmc.igh.data %>% glimpse()
```

For each sequence, add the hamming distance to its nearest neighbour using the distToNearest function:
```{r add_nearest_dists}
#add the distance to the nearest other heavy chain in the dataset to the tibbles
pbmc.igh.data <- distToNearest(pbmc.igh.data, nproc = 1)
tumour.igh.data <- distToNearest(tumour.igh.data, nproc = 1)

#summarise the dists from the PBMC
summary(pbmc.igh.data$dist_nearest)
```

Plotting the distances to look for the valley of the bimodal distribution that should provide a threshold between clonal and unrelated sequences:
```{r plotting_nearest_dists_pbmc}
#plotting the distribution
pbmc.dist.p1 <- ggplot(pbmc.igh.data %>% filter(!is.na(dist_nearest)),
             aes(x = dist_nearest)) +
  theme_bw() +
  xlab("Hamming distance") + ylab("Count") +
  scale_x_continuous(breaks = seq(0, 1, 0.1)) +
  geom_histogram(color = "white", binwidth = 0.02) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_custom()
plot(pbmc.dist.p1)
```

There don't appear to be many clonally related sequences in the dataset, but a threshold of 0.1 should split the clones from the unrelated sequences:
```{r plotting_nearest_dists_pbmc2}
#add a line for threshold
pbmc.dist.p1 <- pbmc.dist.p1 +
  geom_vline(xintercept = 0.1, linetype = "dashed", colour = "firebrick")
plot(pbmc.dist.p1)
```

Now, repeating the process for the IGH from the tumour datasets:
```{r plotting_nearest_dists_tumour}
#plotting distribution for the tumour sample
tumour.dist.p1 <- ggplot(tumour.igh.data %>% filter(!is.na(dist_nearest)),
                       aes(x = dist_nearest)) +
  theme_bw() +
  xlab("Hamming distance") + ylab("Count") +
  scale_x_continuous(breaks = seq(0, 1, 0.1)) +
  geom_histogram(color = "white", binwidth = 0.02) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_custom()
plot(tumour.dist.p1)
```

For the tumour IGH dataset the 'valley' is less defined, but 0.1 looks okays:
```{r plotting_nearest_dists_tumour2}
#add a line for threshold
tumour.dist.p1 <- tumour.dist.p1 +
  geom_vline(xintercept = 0.1, linetype = "dashed", colour = "firebrick")
plot(tumour.dist.p1)
```

Opting to use a threshold of 0.1 for both datasets, save this to the threshold variable:
```{r set_threshold}
#looks like 0.1 would be suitable threshold for both samples
threshold <- 0.1
```

```{r print_set_threshold, echo = FALSE}
#print the threshold
threshold
```

## Building the clones within each dataset

To run the clone building in 'single-cell' mode need to reformat the tibble to have igh and igkl as separate rows:
```{r refomat_set_for_cln_building}
pbmc.igkl.data <- pbmc.data %>% 
  select(barcode, sequence_id = contig_id_igkl, ends_with("_igblast_igkl")) %>%
  rename_with(~ str_replace(.x, "_igblast_igkl", ""), everything()) %>%
  filter(!(is.na(cdr3))) #need to remove any unpaired entries as they will cause errors

tumour.igkl.data <- tumour.data %>%
  select(barcode, sequence_id = contig_id_igkl, ends_with("_igblast_igkl")) %>%
  rename_with(~ str_replace(.x, "_igblast_igkl", ""), everything()) %>%
  filter(!(is.na(cdr3))) #need to remove any unpaired entries as they will cause errors

#combine the igh and igkl from each together to a single tibble
pbmc.input <- bind_rows(pbmc.igh.data, pbmc.igkl.data) 
tumour.input <- bind_rows(tumour.igh.data, tumour.igkl.data )
```

These tibbles will now have two entries for cell barcodes that had paired chains (or a single entry for a cell barcode that only had a single chain):
```{r view_reformat_cln_building}
pbmc.input %>% glimpse()
```

The clones will be generated using the hierarchicalClones from the SCOPer package. This function will add a clone_id column to the input tibble and entries that share the same clone_id are considered members of the same clonal lineage:
```{r build_clones}
#add the clone id columns for PBMC
pbmc.input <- hierarchicalClones(pbmc.input, 
                              threshold = threshold,
                              cell_id = "barcode",
                              method = "nt",
                              linkage = "average",
                              junction = "cdr3",
                              only_heavy = FALSE, 
                              split_light = TRUE,
                              summarize_clones = FALSE)

#add the clone id columns for tumour
tumour.input <- hierarchicalClones(tumour.input, 
                                   threshold = threshold,
                                   cell_id = "barcode",
                                   method = "nt",
                                   linkage = "average",
                                   junction = "cdr3",
                                   only_heavy = FALSE, 
                                   split_light = TRUE,
                                   summarize_clones = FALSE)

```

Extract these clone IDs and add them to the original tibble that summarises the igblast + cellranger for each cell barcode:
```{r extract_cln_ids}
#extract the clone_id and add back to the main tibble
pbmc.clns <- pbmc.input %>%
  select(barcode, clone_id) %>%
  unique() %>% #as data is formatted as IGH and IGK/L as separate entries the barcode + clone_id is duplicated for IGH and IGK/l
  mutate(dataset = "pbmc")

tumour.clns <- tumour.input %>%
  select(barcode, clone_id) %>%
  unique() %>%
  mutate(dataset = "tumour")

#combine the pbmc & tumour clone IDs
cln.data <- bind_rows(pbmc.clns, tumour.clns) 

cln.data %>% head()
```

Merge the BCR data that originally loaded with the clone labels just created:
```{r add_cln_ids}
#joining the clone_ids by barcode & dataset
bcr.cln.data <- bcr.data %>%
  left_join(cln.data, by = c("barcode", "dataset"))

#check that the number of rows match
bcr.data %>% nrow() == bcr.cln.data %>% nrow()
```

As PBMC and tumour data are in same tibble, the clone_ids are not unique as some ID can be in both datasets, to avoid confusion, create a unqiue clone ID by combining the dataset and clone_ID:
```{r add_unq_cln_id}
#add a unique labels for the clns that is the clone_id + dataset
bcr.cln.data <- bcr.cln.data %>%
  mutate(unq_clone_id = ifelse(is.na(clone_id), NA_character_, paste(dataset, clone_id, sep = "_")))
```

A quick summary of clone sizes to check if there are any expanded clones:
```{r cln_size_summary}
#quick summary of clone sizes
cln.size.summary <- bcr.cln.data %>%
  filter(!(is.na(unq_clone_id))) %>% #remove cells that lack a clone call
  group_by(dataset, unq_clone_id) %>% #group by clone_id & dataset
  summarise(cln_size = length(barcode)) %>% #count the number of barcodes in each clones
  ungroup() %>% #remove the grouping
  arrange(desc(cln_size)) #reorder the data from largest to smallest clone size across the two datasets

cln.size.summary
```

## Outputting datasets

Write the bcr data that now includes the clone ID to a tab-delimited file:
```{r output_data}
write_tsv(bcr.cln.data, "pbmc-tumour_Ig_cellranger_igblast_per-barcode_clns.tsv")
```
